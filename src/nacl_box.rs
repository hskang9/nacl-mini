use crypto::{curve25519, salsa20, poly1305};

use crypto::symmetriccipher::SynchronousStreamCipher;
use crypto::mac::Mac;

use super::{PublicX25519, Secret, Error}; 


static VERSION: &str = "x25519-xsalsa20-poly1305";

pub const PRIVATE_KEY_BYTES: usize = 32;
pub const NONCE_BYTES: usize = 24;
pub const SECRET_BYTES: usize =32;
pub const MAC_BYTES: usize = 16;





fn poly1305_(key: &[u8], msg: &[u8], mac: &mut [u8]){
    
    let mut poly = poly1305::Poly1305::new(key);
    poly.input(msg);
    poly.raw_result(mac);
    
}

fn precompute(pk:&PublicX25519, sk: &Secret)->[u8;SECRET_BYTES]{
    let zeros = [0u8;16];
    let mut first_key = [0u8;32];

    let shared =curve25519::curve25519(sk.as_ref(), pk.as_ref());
    salsa20::hsalsa20(&shared, &zeros, &mut first_key);
    
    first_key

}

fn secretbox_seal(msg: &[u8], nonce: &[u8;NONCE_BYTES], key:&[u8;SECRET_BYTES] ) -> Result< Vec<u8>, Error>
{

    let mut xs = salsa20::Salsa20::new_xsalsa20(key, nonce);

    //key for Poly1305 generated by encrypting 32 bytes of zeros
    let pzero =[0u8;32];
    let mut poly_key = [0u8; 32];
    
    xs.process(&pzero, &mut poly_key);
    
    let mut out = vec![0u8; msg.len() + MAC_BYTES];

    //encrypt stream
    xs.process( msg, &mut out[MAC_BYTES..]);

    {
        let (left, right) = out.split_at_mut(MAC_BYTES);
        poly1305_(&poly_key,right, left);
    }
   

    Ok(out)

}

pub fn seal(msg: &[u8], nonce: &[u8;NONCE_BYTES], their_public: &PublicX25519,
                our_secret: &Secret) -> Result< Vec<u8>, Error>
{

    let key = precompute(their_public, our_secret);
    secretbox_seal(msg, nonce, &key)        


}



pub fn secretbox_open(cipher: &[u8], nonce: &[u8;NONCE_BYTES], key: &[u8;SECRET_BYTES])->Result< Vec<u8> , Error>
{

    if cipher.len() < MAC_BYTES{
        return Err(Error::Custom(String::from("Message is invalid")));
    }
    let mut xs = salsa20::Salsa20::new_xsalsa20(key, nonce);
    
    let mut poly_key = [0u8; 32];
    let pzero =[0u8;32];
    xs.process(&pzero, &mut poly_key);


    //Verify Mac
    let mac = &cipher[..MAC_BYTES];
    let mut tmp= [0u8; MAC_BYTES];
    poly1305_( &poly_key, &cipher[MAC_BYTES..],&mut tmp );
    
    if !crypto::util::fixed_time_eq(mac,&tmp ){
        return Err(Error::Custom(String::from("Message Authentication Failed!")));
    }

    //Decrypt 
    let mut out = vec![0u8; cipher.len() - MAC_BYTES];
    xs.process(&cipher[MAC_BYTES..], &mut out);
    
    Ok(out)

}



pub fn open(cipher: &[u8], nonce: &[u8;NONCE_BYTES], their_public: &PublicX25519, our_secret: &Secret)
    -> Result< Vec<u8>, Error>
{
    
    let shared_key = precompute(their_public, our_secret);   
    secretbox_open(cipher, nonce, &shared_key) 
    
}


#[cfg(test)]
mod test{


    use super::*;
    use super::super::KeyPairX25519;

    const ALICESK: [u8;32] =
        [  
             0x77,0x07,0x6d,0x0a,0x73,0x18,0xa5,0x7d
            ,0x3c,0x16,0xc1,0x72,0x51,0xb2,0x66,0x45
            ,0xdf,0x4c,0x2f,0x87,0xeb,0xc0,0x99,0x2a
            ,0xb1,0x77,0xfb,0xa5,0x1d,0xb9,0x2c,0x2a
        ];

    const BOBSK: [u8;32]=
        [
            0x5d,0xab,0x08,0x7e,0x62,0x4a,0x8a,0x4b
            ,0x79,0xe1,0x7f,0x8b,0x83,0x80,0x0e,0xe6
            ,0x6f,0x3b,0xb1,0x29,0x26,0x18,0xb6,0xfd
            ,0x1c,0x2f,0x8b,0x27,0xff,0x88,0xe0,0xeb
        
        ];

    const DJB_SUBKEY: [u8;32] =
        [
            0x1b,0x27,0x55,0x64,0x73,0xe9,0x85,0xd4
            ,0x62,0xcd,0x51,0x19,0x7a,0x9a,0x46,0xc7
            ,0x60,0x09,0x54,0x9e,0xac,0x64,0x74,0xf2
            ,0x06,0xc4,0xee,0x08,0x44,0xf6,0x83,0x89

        ];


    const DJB_NONCE: [u8;24]=
        [
                0x69,0x69,0x6e,0xe9,0x55,0xb6,0x2b,0x73
                ,0xcd,0x62,0xbd,0xa8,0x75,0xfc,0x73,0xd6
                ,0x82,0x19,0xe0,0x03,0x6b,0x7a,0x0b,0x37
        
        
        ];



    #[test]
    fn test_precompute(){
       let kp = KeyPairX25519::from_secret_slice(&BOBSK)
                    .unwrap();
        let bob_pk =    kp.public(); 
    
        let alice_sk = Secret::from_unsafe_slice(&ALICESK).unwrap();
    
        let fk = precompute(&bob_pk, &alice_sk);


        assert_eq!(fk, DJB_SUBKEY);


    }
    #[test]
    fn test_seal_open(){
        let djb_sample =
            vec![
                0xbe,0x07,0x5f,0xc5,0x3c,0x81,0xf2,0xd5
                ,0xcf,0x14,0x13,0x16,0xeb,0xeb,0x0c,0x7b
                ,0x52,0x28,0xc5,0x2a,0x4c,0x62,0xcb,0xd4
                ,0x4b,0x66,0x84,0x9b,0x64,0x24,0x4f,0xfc
                ,0xe5,0xec,0xba,0xaf,0x33,0xbd,0x75,0x1a
                ,0x1a,0xc7,0x28,0xd4,0x5e,0x6c,0x61,0x29
                ,0x6c,0xdc,0x3c,0x01,0x23,0x35,0x61,0xf4
                ,0x1d,0xb6,0x6c,0xce,0x31,0x4a,0xdb,0x31
                ,0x0e,0x3b,0xe8,0x25,0x0c,0x46,0xf0,0x6d
                ,0xce,0xea,0x3a,0x7f,0xa1,0x34,0x80,0x57
                ,0xe2,0xf6,0x55,0x6a,0xd6,0xb1,0x31,0x8a
                ,0x02,0x4a,0x83,0x8f,0x21,0xaf,0x1f,0xde
                ,0x04,0x89,0x77,0xeb,0x48,0xf5,0x9f,0xfd
                ,0x49,0x24,0xca,0x1c,0x60,0x90,0x2e,0x52
                ,0xf0,0xa0,0x89,0xbc,0x76,0x89,0x70,0x40
                ,0xe0,0x82,0xf9,0x37,0x76,0x38,0x48,0x64
                ,0x5e,0x07,0x05
            
            ];

        let djb_encrypted =
            vec![
                0xf3,0xff,0xc7,0x70,0x3f,0x94,0x00,0xe5
                ,0x2a,0x7d,0xfb,0x4b,0x3d,0x33,0x05,0xd9
                ,0x8e,0x99,0x3b,0x9f,0x48,0x68,0x12,0x73
                ,0xc2,0x96,0x50,0xba,0x32,0xfc,0x76,0xce
                ,0x48,0x33,0x2e,0xa7,0x16,0x4d,0x96,0xa4
                ,0x47,0x6f,0xb8,0xc5,0x31,0xa1,0x18,0x6a
                ,0xc0,0xdf,0xc1,0x7c,0x98,0xdc,0xe8,0x7b
                ,0x4d,0xa7,0xf0,0x11,0xec,0x48,0xc9,0x72,
                0x71,0xd2,0xc2,0x0f,0x9b,0x92,0x8f,0xe2
                ,0x27,0x0d,0x6f,0xb8,0x63,0xd5,0x17,0x38
                ,0xb4,0x8e,0xee,0xe3,0x14,0xa7,0xcc,0x8a
                ,0xb9,0x32,0x16,0x45,0x48,0xe5,0x26,0xae
                ,0x90,0x22,0x43,0x68,0x51,0x7a,0xcf,0xea
                ,0xbd,0x6b,0xb3,0x73,0x2b,0xc0,0xe9,0xda
                ,0x99,0x83,0x2b,0x61,0xca,0x01,0xb6,0xde
                ,0x56,0x24,0x4a,0x9e,0x88,0xd5,0xf9,0xb3
                ,0x79,0x73,0xf6,0x22,0xa4,0x3d,0x14,0xa6
                ,0x59,0x9b,0x1f,0x65,0x4c,0xb4,0x5a,0x74
                ,0xe3,0x55,0xa5
            
            ];
        let alice_kp = KeyPairX25519::from_secret_slice(&ALICESK).unwrap();
        let bob_kp = KeyPairX25519::from_secret_slice(&BOBSK).unwrap();
        
        let encrypt = seal(&djb_sample.as_slice(), &DJB_NONCE, bob_kp.public(), alice_kp.secret());
        let encrypt = encrypt.unwrap();  

        assert_eq!(encrypt, djb_encrypted);

        let plain = open(&djb_encrypted, &DJB_NONCE, alice_kp.public(), bob_kp.secret());
        let plain = plain.unwrap();

        assert_eq!(plain, djb_sample);
        
  
    }
}
